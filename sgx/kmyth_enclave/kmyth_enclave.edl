enclave {
	from "sgx_tstdc.edl" import *;
	from "sgx_tsgxssl.edl" import *;
	from "sgx_pthread.edl" import *;
	include "sgx_tseal.h"
	include "stdbool.h"
    trusted {
/**
 * @brief Seals input data using SGXs built-in sealing mechanism.
 *
 * @param[in]  in_data  Pointer to the data to be sealed.
 *
 * @param[in]  in_size  The size of in_data in bytes.
 *
 * @param[out] out_data Pointer to space to hold the encrypted data, must
 *                      allready be allocated with size out_size.
 *
 * @param[in]  out_size  The size of out_data. Must be determined by first
 *                       calling enc_get_sealed_size with in_size.
 *
 * @param[in]  key_policy The SGX key policy to use for the sealing key.
 *                        Must be SGX_KEYPOLICY_MRSIGNER (to bind to the 
 *                        signer of the enclave) or SGX_KEYPOLICY_MRENCLAVE
 *                        (to bind to the enclave.)
 * 
 * @param[in] attribute_mask The SGX attribute mask structure to be used for
 *                           the sealing. If attribute_mask.flags is 0 the
 *                           recommended default value will be used.
 *
 * @return 0 on success, an SGX error on error.
 */
        public int enc_seal_data(
                [in, size=in_size] const uint8_t *in_data,
                uint32_t in_size,
                [user_check] uint8_t *out_data,
                uint32_t out_size,
		uint16_t key_policy,
		sgx_attributes_t attribute_mask);

/**
 * @brief Computes the output buffer size required to seal input data
 *        of size in_size.
 *
 * @param[in]  in_size The size of the plaintext data to be encrypted
 *
 * @param[out] size    The size of the ciphertext
 *
 * @return 0 in success, SGX_ERROR_INVALID_PARAMETER on error
 */
        public int enc_get_sealed_size(
                uint32_t in_size,
                [out, count=1] uint32_t *size);

        public int enc_run_dh_key_exchange(
                [in, size=private_host_key_len] unsigned char *private_host_key,
                size_t private_host_key_len,
                [in, size=public_peer_key_len] unsigned char *public_peer_key,
                size_t public_peer_key_len,
                [user_check] unsigned char **key,
                [out, count=1] size_t *key_len,
                [out, size=error_buffer_len] char *error_buffer,
                size_t error_buffer_len);
    };

/**
 * @brief SGX unseals the provided data and places it into the
 *        kmyth_unsealed_data_table.
 *
 * @param[in] data_size The size of the ciphertext
 *
 * @param[in] data      The ciphertext
 *
 * @param[out] handle   A pointer to a uint64_t to hold the handle.
 *
 * @return true on success, false on failure. The return value MUST be checked.
 *
 */
 public bool kmyth_unseal_into_enclave(uint32_t data_size, [in, count=data_size] uint8_t* data, [out] uint64_t* handle);

/**
 * @brief Initializes the necessary values to maintain kmyth_unsealed_data_table.
 *
 * @return 0 on success, -1 on failure.
 */
 public int kmyth_unsealed_data_table_initialize(void);

/**
 * @brief Cleans up (and frees all memory for) the kmyth_unsealed_data_table.
 *
 * @return 0 on success, -1 on failure.
 */
 public int kmyth_unsealed_data_table_cleanup(void);
    };
};
